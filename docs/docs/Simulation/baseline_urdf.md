---
layout: default
title: Baseline URDF
parent: Simulation
nav_order: 2
---

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>


## Introduction

Let's build a simple 4 wheel robot in a modular fashion without worrying about the visual
aspects. We will use the URDF format to define the robot and the world.

# Baseline URDF

## Achieving Modular Design

- XACRO is a macro for URDF which allows us to import child URDFs into a parent URDF.
- In our application, I wanted the wheel module to be a separate URDF which can be imported into the main URDF.
- Here's a simple example of a wheel module in a file called `wheel.urdf.xacro`:

```xml
<?xml version="1.0"?>

<robot name="wheel" xmlns:xacro="http://www.ros.org/wiki/xacro">

  <xacro:macro name="wheel" params="name">
    <link name="${name}_link">
      <visual>
        <geometry>
          <cylinder radius="0.1" length="0.05"/>
        </geometry>
      </visual>
    </link>
    <joint name="${name}_joint" type="continuous">
      <parent link="${name}_link"/>
      <child link="${name}_wheel"/>
      <origin xyz="0 0 0.05"/>
      <axis xyz="0 0 1"/>
    </joint>
    <link name="${name}_wheel">
      <visual>
        <geometry>
          <cylinder radius="0.1" length="0.05"/>
        </geometry>
      </visual>
    </link>
  </xacro:macro>

</robot>
```

- The `wheel` macro defines a wheel with a cylinder link and a joint to connect the wheel to the robot.
- The `wheel` macro can be imported into the main URDF using the following syntax:

```xml
<?xml version="1.0"?>
<robot name="robot" xmlns:xacro="http://www.ros.org/wiki/xacro">

  <xacro:include filename="wheel.urdf.xacro"/>

  <xacro:wheel name="front_left"/>
  <xacro:wheel name="front_right"/>
  <xacro:wheel name="rear_left"/>
  <xacro:wheel name="rear_right"/>

</robot>
```

## Visualizing the XACRO

- The TF2 frames are generated by the `robot_state_publisher` node. This needs URDF as input
- Therefore XACRO needs to be converted to URDF. This can be done in two ways:

### Using `xacro` Command Line Tool:

```bash
ros2 run xacro xacro -o robot.urdf robot.urdf.xacro
```

### Using a Launch File:

```python
import os
import launch
import xacro
import launch_ros.actions

from launch import LaunchDescription
from launch.substitutions import LaunchConfiguration
from launch.actions import DeclareLaunchArgument
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory


def generate_launch_description():
    # Check if we're told to use sim time
    use_sim_time = LaunchConfiguration('use_sim_time')
    package_dir = get_package_share_directory('simulation_launch')
    rviz_config_file = os.path.join(package_dir,'rviz', 'rviz_config.rviz')

    # if using xacro it needs to be processed first
    xacro_file = os.path.join(package_dir, 'description', 'robot.urdf.xacro')
    robot_description_config = xacro.process_file(xacro_file)
    params = {'robot_description': robot_description_config.toxml(), 'use_sim_time': use_sim_time}

    return LaunchDescription([
        DeclareLaunchArgument(
            'use_sim_time',
            default_value='false',
            description='Use sim time if true'),
        Node(
            package='rviz2',
            executable='rviz2',
            name='rviz2',
            output='screen',
            arguments=['-d', rviz_config_file]
        ),
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            output='screen',
            parameters=[params]
        ),
        # Create a joint_state_publisher_gui node
        Node(
            package='joint_state_publisher_gui',
            executable='joint_state_publisher_gui',
            name='joint_state_publisher_gui',
            output='screen'
        )
    ])
```

NOTE: The `joint_state_publisher_gui` node is used to publish a TF2 transforms between all
non-fixed links in the URDF.

This can be done in other nodes as well, but the `joint_state_publisher_gui` is a convenient